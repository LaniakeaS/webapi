import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
 * This is a simple program for encoding and decoding messages using AES (Advanced Encrypt Algorithm).
 * 
 * Students are allowed to use and modify this program for any purposes.
 * 
 * @author Dr. Scott Piao. LUC-BJTU.
 * @author Chen Yuetao
 */
class MyCryptoTool {
    
    /**
     * Encrypts normal message into Cypher message.
     * 
     * @param message Original message.
     * @param myKey A secrete key of String.
     * @param ivStr A set of 16 numbers to create the initialization vector (IV).
     * @return The encrypted message in a byte array.
     */
    public static byte[] encyptMessage(String message, String myKey, String ivStr) {
        try {
            SecretKeySpec secretKey = getSecretKey(myKey);
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

            //IV - initialization vector
            IvParameterSpec ivParam = new IvParameterSpec(ivStr.getBytes());

            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParam);

            byte[] encrypResult = cipher.doFinal(message.getBytes());

            //String cipherMessage = new String(encrypResult);

            return encrypResult;
            //return cipherMessage;
        } catch (Exception e) {
            System.out.println("Something went wrong!");
            return null;
        }

    }

    /**
     * Decrypts Cipher message into original message.
     * 
     * @param cipherMessage Cipher message.
     * @param myKey A secrete key of String. Should be the same key used for encryption.
     * @param ivStr A set of 16 numbers to create the initialization vector (IV). Should be the same numbers used for encryption.
     * @return The original message in a String.
     */
    public static String decryptMessage(byte[] cipherMessage, String myKey, String ivStr) {
        
        try {
            SecretKeySpec secretKey = getSecretKey(myKey);
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            IvParameterSpec ivParam = new IvParameterSpec(ivStr.getBytes());
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParam);
            byte[] original = cipher.doFinal(cipherMessage);
            String decodedMessage = new String(original);
            return decodedMessage;
        } catch (Exception ex) {
            return null;
        }
    }
    
    /**
     * Generates a secrete key based on users String key using a certain algorithm.
     * 
     * @param stringKey Users Key in the form of Sring.
     * @return A secrete key generated by an algorithm based on the String Key.
     */
    private static SecretKeySpec getSecretKey(String stringKey) throws Exception {
        byte[] arrayBytes = stringKey.getBytes();
        byte[] arrayBytes16 = new byte[16]; // create 16 byte array

        for (int i = 0; i < arrayBytes.length && i < arrayBytes16.length; i++) {
            arrayBytes16[i] = arrayBytes[i];
        }

        SecretKeySpec secretKeySpec = new SecretKeySpec(arrayBytes16, "AES");
        return secretKeySpec;
    }

    /**
     * Generate the secret string from name, password and time by MD5.
     * @param name user's name
     * @param password user's password
     * @param time user's last login time
     * @return
     */
    public static String generateSecretStr(String name, String password, String time) {
        String originStr = name + password + time;
        StringBuilder secretStr = new StringBuilder();
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
            messageDigest.update(originStr.getBytes(StandardCharsets.UTF_8));
            byte[] secretKeyInBytes = messageDigest.digest();
            for (byte secretKeyInByte : secretKeyInBytes) {
                int secretKeyInByteInt = secretKeyInByte;
                if (secretKeyInByteInt < 0)
                    secretKeyInByteInt += 256;
                if (secretKeyInByteInt < 16)
                    secretStr.append("0");
                secretStr.append(Integer.toHexString(secretKeyInByteInt));
            }
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return secretStr.substring(8, 24);
    }


}
